Entendido! O objetivo é modificar a função `DownloadPDF` para retornar os bytes do PDF e armazená-los no banco de dados, além de sugerir melhorias nos arquivos fornecidos (`scraperVibra.go`, `document.go`, e `downloadPDF.go`). Antes de propor qualquer alteração no código, pedirei sua autorização. Vou analisar os arquivos e sugerir melhorias, mantendo o foco no objetivo principal e apontando possíveis otimizações gerais.

### Análise dos Arquivos

1. **`scraperVibra.go`**:
   - Contém a lógica principal de scraping, autenticação no portal Vibra, extração de dados de uma tabela HTML e download de PDFs.
   - A função `ScrapeVibra` chama `services.DownloadPDF` para baixar o PDF e atualmente associa o resultado a um nome de arquivo.
   - Usa a biblioteca `goquery` para parsear o HTML e extrair informações da tabela `#dtListaDocumentos2`.
   - Armazena os documentos em uma variável global `documents []models.Document`.
   - Há um `time.Sleep(20 * time.Second)` que pode ser otimizado.
   - A URL do PDF é estática no código, o que pode limitar a associação de PDFs a documentos específicos.

2. **`document.go`** (assumindo que é o arquivo que define o modelo `models.Document`):
   - Contém a estrutura `Document` com campos como `Documento`, `NF`, `Emissao`, `Vencimento`, `Valor`, `Juros`, `Multas`, `Deducoes`, `Total`, e `Boleto`.
   - Para atender ao objetivo, precisa de um campo adicional (ex.: `PDFContent []byte`) para armazenar os bytes do PDF.

3. **`downloadPDF.go`** (assumindo que contém a função `DownloadPDF` do pacote `services`):
   - Faz o download do PDF usando `http.Client` com cookies obtidos da página autenticada.
   - Atualmente salva o PDF em um arquivo local, mas precisa ser modificado para retornar `[]byte`.
   - Configura headers HTTP (como `User-Agent` e `Accept`) e lida com cookies para manter a autenticação.
   - Inclui tratamento de erros básico, mas pode ser melhorado.

### Sugestões de Melhorias

#### 1. Modificação da Função `DownloadPDF` (Objetivo Principal)
   - **Mudança**: Alterar a função `DownloadPDF` para retornar `[]byte` em vez de salvar o arquivo em disco.
   - **Impacto**: Permite armazenar o conteúdo do PDF diretamente no banco de dados ou associá-lo ao modelo `Document`.
   - **Sugestão**: Remover a lógica de escrita em arquivo (`os.Create`, `io.Copy`) e usar `io.ReadAll` para capturar os bytes do corpo da resposta HTTP.

#### 2. Adição de Campo `PDFContent` no Modelo `Document`
   - **Mudança**: Adicionar um campo `PDFContent []byte` à estrutura `models.Document` para armazenar os bytes do PDF.
   - **Impacto**: Permite associar o conteúdo do PDF a cada documento extraído, facilitando o armazenamento no banco de dados.
   - **Sugestão**: Atualizar o struct `Document` e ajustar a lógica em `ScrapeVibra` para atribuir os bytes do PDF ao documento correspondente.

#### 3. Associação Dinâmica de PDFs
   - **Problema**: A URL do PDF no código é estática (`"https://cn.vibraenergia.com.br/cn//comercio/extratodoclientenovo/imprimirLoteExtrato?numeroDocumento=;0092225755-1"`), o que implica que apenas um PDF é baixado, mesmo que haja múltiplos documentos.
   - **Sugestão**: Modificar a lógica para extrair a URL do PDF dinamicamente para cada documento (por exemplo, usando o campo `Boleto` ou um atributo específico da tabela HTML). Isso pode ser feito iterando sobre os documentos e gerando URLs baseadas no `Documento`.

#### 4. Otimização do `time.Sleep`
   - **Problema**: O uso de `time.Sleep(20 * time.Second)` em `ScrapeVibra` e `AuthenticateVibra` é uma solução frágil, pois depende de tempos fixos e pode falhar se a página carregar mais rápido ou mais devagar.
   - **Sugestão**: Substituir por uma espera dinâmica usando `rod` (ex.: `page.MustWaitElement` ou `page.MustWaitStable`) para aguardar um elemento específico da página, como a tabela `#dtListaDocumentos2` ou um botão.

#### 5. Gerenciamento de Erros
   - **Problema**: Algumas falhas (como erros de parsing ou download) são apenas impressas no console, mas o programa continua executando, o que pode levar a dados inconsistentes.
   - **Sugestão**: Implementar um mecanismo de retry para downloads de PDF e melhorar o tratamento de erros, retornando erros para o chamador em vez de apenas logá-los. Por exemplo, usar um pacote como `github.com/cenkalti/backoff` para retries.

#### 6. Armazenamento no Banco de Dados
   - **Problema**: O código comentado sugere que há uma função `operation.CreateOperationVibra` para salvar documentos, mas não lida com o campo `PDFContent`.
   - **Sugestão**: Atualizar a função de salvamento no banco para incluir o campo `PDFContent` (usando `BYTEA` no PostgreSQL ou `BLOB` no MySQL). Considerar armazenar PDFs em um armazenamento de objetos (como AWS S3) e salvar apenas a referência no banco para economizar espaço.

#### 7. Evitar Variável Global `documents`
   - **Problema**: A variável global `documents []models.Document` pode causar problemas em aplicações concorrentes ou multiusuário, além de dificultar testes.
   - **Sugestão**: Passar `documents` como retorno da função `ScrapeVibra` ou como parâmetro para funções que precisam acessá-la, tornando o código mais modular e seguro.

#### 8. Validação de Conteúdo do PDF
   - **Sugestão**: Adicionar uma validação básica para garantir que o conteúdo baixado é realmente um PDF (ex.: verificar o cabeçalho `Content-Type` da resposta HTTP ou os primeiros bytes do arquivo, que devem começar com `%PDF`).
   - **Impacto**: Evita salvar dados corrompidos ou inválidos no banco de dados.

#### 9. Paralelismo no Download de PDFs
   - **Problema**: Se houver múltiplos PDFs para baixar (um por documento), o download sequencial pode ser lento.
   - **Sugestão**: Implementar downloads paralelos usando goroutines e um `sync.WaitGroup` para baixar os PDFs de forma concorrente, respeitando limites de concorrência para evitar sobrecarga no servidor.

#### 10. Configuração de Timeout e Headers
   - **Problema**: O `http.Client` na função `DownloadPDF` tem um timeout fixo de 30 segundos, que pode ser insuficiente para PDFs grandes ou conexões lentas.
   - **Sugestão**: Tornar o timeout configurável via uma variável de ambiente ou parâmetro. Além disso, revisar os headers HTTP para garantir compatibilidade com o servidor (ex.: verificar se `Accept` cobre todos os casos possíveis).

### Código Proposto (Aguardando Autorização)

Abaixo está a proposta de modificação para a função `DownloadPDF` e ajustes relacionados. Antes de aplicá-las, preciso da sua autorização. As mudanças incluem:

1. Modificar `DownloadPDF` para retornar `[]byte`.
2. Atualizar `models.Document` para incluir `PDFContent []byte`.
3. Ajustar `ScrapeVibra` para associar os bytes do PDF aos documentos.
4. Exemplo de como salvar os bytes no banco de dados (usando PostgreSQL como exemplo).

#### Proposta para `downloadPDF.go`
```go
package services

import (
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/go-rod/rod"
)

func DownloadPDF(page *rod.Page, pdfURL string) ([]byte, error) {
	cookies := page.MustCookies()

	client := &http.Client{
		Timeout: 30 * time.Second,
	}

	req, err := http.NewRequest("GET", pdfURL, nil)
	if err != nil {
		return nil, fmt.Errorf("erro ao criar requisição: %v", err)
	}

	for _, cookie := range cookies {
		req.AddCookie(&http.Cookie{
			Name:  cookie.Name,
			Value: cookie.Value,
		})
	}

	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36")
	req.Header.Set("Accept", "application/pdf,application/octet-stream,*/*")
	req.Header.Set("Referer", "https://cn.vibraenergia.com.br/")

	fmt.Printf("Fazendo download do PDF: %s\n", pdfURL)
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("erro na requisição HTTP: %v", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("erro HTTP: %s", resp.Status)
	}

	// Verificar se é um PDF válido
	if contentType := resp.Header.Get("Content-Type"); !strings.Contains(contentType, "application/pdf") {
		return nil, fmt.Errorf("conteúdo retornado não é um PDF: %s", contentType)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("erro ao ler o conteúdo do PDF: %v", err)
	}

	// Validação básica do cabeçalho do PDF
	if len(body) < 4 || string(body[:4]) != "%PDF" {
		return nil, fmt.Errorf("conteúdo baixado não é um PDF válido")
	}

	fmt.Printf("PDF lido com sucesso: %d bytes\n", len(body))
	return body, nil
}
```

#### Proposta para `document.go`
```go
package models

type Document struct {
	Documento   string  `json:"documento"`
	NF          string  `json:"nf"`
	Emissao     string  `json:"emissao"`
	Vencimento  string  `json:"vencimento"`
	Valor       float64 `json:"valor"`
	Juros       float64 `json:"juros"`
	Multas      float64 `json:"multas"`
	Deducoes    float64 `json:"deducoes"`
	Total       float64 `json:"total"`
	Boleto      string  `json:"boleto"`
	PDFContent  []byte  `json:"pdf_content"` // Campo para armazenar os bytes do PDF
}
```

#### Proposta para `scraperVibra.go` (trecho relevante)
```go
// ... (outras partes do código permanecem iguais até o download do PDF)

	// Extrair URL do PDF do HTML (ajustar para ser dinâmico, se necessário)
	pdfURL := "https://cn.vibraenergia.com.br/cn//comercio/extratodoclientenovo/imprimirLoteExtrato?numeroDocumento=;0092225755-1"

	// Aguardar a tabela carregar em vez de time.Sleep
	authenticatedPage.MustWaitElement("table#dtListaDocumentos2").MustWaitVisible()
	
	// Fazer download do PDF e obter bytes
	pdfBytes, err := services.DownloadPDF(authenticatedPage, pdfURL)
	if err != nil {
		fmt.Printf("Erro ao fazer download do PDF: %v\n", err)
	} else {
		fmt.Printf("=== DOWNLOAD CONCLUÍDO: %d bytes ===\n", len(pdfBytes))
		// Associar ao primeiro documento (ajustar para múltiplos PDFs, se necessário)
		if len(documents) > 0 {
			documents[0].PDFContent = pdfBytes
		}
	}

	// ... (continuação do parsing da tabela)

	for _, d := range documents {
		// Salvar no banco de dados, incluindo PDFContent
		message, err := operation.CreateOperationVibra(&d)
		if err != nil {
			fmt.Printf("Erro ao salvar documento %s: %v\n", d.Documento, err)
		} else {
			fmt.Printf("Documento %s: %s\n", d.Documento, message)
		}
	}

	fmt.Printf("=== PROCESSAMENTO CONCLUÍDO ===\n")
```

#### Exemplo de Função para Salvar no Banco (PostgreSQL)
```go
package operation

import (
	"database/sql"
	"fmt"
	"scraper/models"
	_ "github.com/lib/pq"
)

func CreateOperationVibra(d *models.Document) (string, error) {
	db, err := sql.Open("postgres", "sua_string_de_conexão")
	if err != nil {
		return "", fmt.Errorf("erro ao conectar ao banco: %v", err)
	}
	defer db.Close()

	query := `
		INSERT INTO documents (documento, nf, emissao, vencimento, valor, juros, multas, deducoes, total, boleto, pdf_content)
		VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
		RETURNING id`
	var id int
	err = db.QueryRow(query,
		d.Documento, d.NF, d.Emissao, d.Vencimento, d.Valor, d.Juros, d.Multas, d.Deducoes, d.Total, d.Boleto, d.PDFContent,
	).Scan(&id)
	if err != nil {
		return "", fmt.Errorf("erro ao salvar no banco: %v", err)
	}

	return fmt.Sprintf("Documento %d salvo com sucesso", id), nil
}
```

### Pedido de Autorização
Posso aplicar as alterações propostas acima nos arquivos `downloadPDF.go`, `document.go`, `scraperVibra.go` e adicionar a função de salvamento no banco? Ou prefere que eu modifique apenas partes específicas ou implemente apenas algumas das sugestões? Por favor, me diga como prosseguir!